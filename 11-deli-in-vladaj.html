
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deli in vladaj &#8212; Programiranje 1</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Dinamično programiranje" href="12-dinamicno-programiranje.html" />
    <link rel="prev" title="Spremenljive podatkovne strukture" href="10-spremenljive-podatkovne-strukture.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  
  <h1 class="site-logo" id="site-title">Programiranje 1</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="00-uvod.html">
   Programiranje 1
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Analiza podatkov
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="01-regularni-izrazi.html">
   Regularni izrazi
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="02-zajem-podatkov.html">
   Zajem podatkov
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03-knjiznica-pandas.html">
   Knjižnica Pandas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04-naivni-bayesov-klasifikator.html">
   Naivni Bayesov klasifikator
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Funkcijsko programiranje
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="05-uvod-v-ocaml.html">
   Uvod v OCaml
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06-funkcije.html">
   Funkcije
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="07-definicije-tipov.html">
   Definicije tipov
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="08-ucinki-in-cistost.html">
   Učinki in čistost
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Podatkovne strukture in algoritmi
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="09-iskalna-drevesa.html">
   Iskalna drevesa
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="10-spremenljive-podatkovne-strukture.html">
   Spremenljive podatkovne strukture
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Deli in vladaj
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="12-dinamicno-programiranje.html">
   Dinamično programiranje
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="13-1-memoizacija-v-pythonu.html">
   Memoizacija v Pythonu
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="13-2-memoizacija-v-ocamlu.html">
   Memoizacija v OCamlu
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/11-deli-in-vladaj.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/11-deli-in-vladaj.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/matijapretnar/programiranje-1/zapiski?urlpath=tree/11-deli-in-vladaj.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hitro-potenciranje">
   Hitro potenciranje
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#urejanje-z-zlivanjem">
   Urejanje z zlivanjem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#casovna-zahtevnost-urejanja-z-zlivanjem">
   <strong>
    Časovna zahtevnost
   </strong>
   urejanja z zlivanjem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hitro-urejanje">
   Hitro urejanje
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="deli-in-vladaj">
<h1>Deli in vladaj<a class="headerlink" href="#deli-in-vladaj" title="Permalink to this headline">¶</a></h1>
<p>Če lahko iz rešitve manjših podnalog sestavimo rešitev celotne naloge, pravimo, da ima naloga <em>lastnost optimalne podstrukture</em>. V tem primeru lahko postopamo v treh korakih:</p>
<ol class="simple">
<li><p>nalogo <strong>razdelimo</strong> na manjše podnaloge</p></li>
<li><p>podnaloge <strong>rekurzivno rešimo</strong></p></li>
<li><p>dobljene rešitve <strong>združimo</strong> v rešitev prvotne naloge</p></li>
</ol>
<p>Vse naloge niso take, na primer problem osmih kraljic, v katerem moramo na šahovsko desko postaviti osem kraljic, tako da se med seboj ne napadajo. Tudi če znamo postaviti štiri kraljice na manjšo ploščo, nam to pri postavljanju osmih kraljic nič ne pomaga.</p>
<p><img alt="8 kraljic" src="_images/8-kraljic.png" /></p>
<p>Ampak precej nalog pa lastnost optimalne strukture ima in pri tem predmetu bomo pogledali dve splošni strategiji za njihovo reševanje. Prva strategija, ki jo bomo spoznali v tem poglavju, je strategija <em>deli in vladaj</em>, v katerem nam uspe nalogo razdeliti na <em>za konstantni faktor</em> manjše podnaloge (na primer iz velikosti <span class="math notranslate nohighlight">\(n\)</span> na velikost <span class="math notranslate nohighlight">\(n / 2\)</span>):</p>
<p><img alt="" src="_images/deli-in-vladaj.png" /></p>
<p>Včasih bodo podnaloge manjše samo za neko konstanto (na primer iz velikosti <span class="math notranslate nohighlight">\(n\)</span> na velikost <span class="math notranslate nohighlight">\(n - 1\)</span>), vendar se bodo med seboj prekrivale, kar bomo izkoristili tako, da bomo vsako rešili le enkrat. V tem primeru govorimo o <em>dinamičnem programiranju</em>, ki ga bomo spoznali kasneje.</p>
<p><img alt="" src="_images/dinamicno-programiranje.png" /></p>
<p>Kadar pa naloge niso ne za konstantni faktor manjše in se ne prekrivajo, pa ni neke splošne strategije in običajno gre za zahtevne naloge, kjer ni učinkovite rešitve.</p>
<p><img alt="" src="_images/preiskovanje.png" /></p>
<p>Oglejmo si strategijo deli in vladaj na nekaj najbolj znanih primerih:</p>
<div class="section" id="hitro-potenciranje">
<h2>Hitro potenciranje<a class="headerlink" href="#hitro-potenciranje" title="Permalink to this headline">¶</a></h2>
<p>Potenciranje lahko definiramo s pomočjo množenja prek sledeče rekurzivne zveze</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  a^0 &amp;= 1 \\
  a^n &amp;= a \cdot a^{n - 1}
\end{aligned}\end{split}\]</div>
<p>ki pa zahteva <span class="math notranslate nohighlight">\(n - 1\)</span> množenj in ima tako časovno zahtevnost <span class="math notranslate nohighlight">\(O(n)\)</span> ob predpostavki, da ima množenje časovno zahtevnost <span class="math notranslate nohighlight">\(O(1)\)</span> (kar pri poljubno velikih številih sicer ni več res). Število množenj lahko zmanjšamo, če opazimo, da lahko sode potence izračunamo kot kvadrate njihovih korenov. Na primer, če poznamo <span class="math notranslate nohighlight">\(a^18\)</span> lahko <span class="math notranslate nohighlight">\(a^36\)</span> izračunamo samo z enim množenjem. Podobno lahko <span class="math notranslate nohighlight">\(a^18\)</span> samo z enim množenjem izračunamo iz <span class="math notranslate nohighlight">\(a^9\)</span>. Pri lihih potencah je postopek le malenkostno drugačen, saj je na primer <span class="math notranslate nohighlight">\(a^9 = a \cdot a^8\)</span>, kjer zopet nastopa soda potenca. V splošnem je torej postopek, ki ga imenujemo <em>hitro potenciranje</em>, podan z rekurzivno zvezo:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  a^0 &amp;= 1 \\
  a^n &amp;= \begin{cases}
    (a^{n / 2})^2 &amp; \text{$n$ je sod} \\
    a \cdot (a^{n / 2})^2 &amp; \text{$n$ je lih}
  \end{cases}
\end{aligned}\end{split}\]</div>
<p>Ker v vsakem koraku <span class="math notranslate nohighlight">\(n\)</span> razpolovimo, moramo narediti približno <span class="math notranslate nohighlight">\(\log_2 n\)</span> množenj, torej je časovna zahtevnost hitrega potenciranja enaka <span class="math notranslate nohighlight">\(O(\log n)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">potenciraj</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">function</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">potenciraj</span> <span class="n">a</span> <span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span> <span class="k">else</span> <span class="n">a</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val potenciraj : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">potenciraj</span> <span class="mi">2</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1024
</pre></div>
</div>
</div>
</div>
<p>Na podoben način lahko z <span class="math notranslate nohighlight">\(O(\log n)\)</span> računskimi operacijami izračunamo tudi <span class="math notranslate nohighlight">\(n\)</span>-to Fibonaccijevo število. Tu seveda predpostavka o konstantnem času odpade, saj števila zelo hitro naraščajo. Definicijo <span class="math notranslate nohighlight">\(F_n = F_{n - 1} + F_{n - 2}\)</span> lahko razširimo v (na prvi pogled nesmiselen) sistem enačb:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  F_n &amp;= F_{n - 1} + F_{n - 2} \\
  F_{n - 1} &amp;= F_{n - 1}
\end{aligned}\end{split}\]</div>
<p>ki pa ga lahko pretvorimo v matrično enačbo</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    F_n \\ F_{n - 1}
  \end{pmatrix}
  =
  \begin{pmatrix}
    1 &amp; 1 \\
    1 &amp; 0
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    F_{n - 1} \\ F_{n - 2}
  \end{pmatrix}\end{split}\]</div>
<p>kar lahko razpišemo v</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    F_n \\ F_{n - 1}
  \end{pmatrix}
  =
  \begin{pmatrix}
    1 &amp; 1 \\
    1 &amp; 0
  \end{pmatrix}^{n - 1}
  \cdot
  \begin{pmatrix}
    F_1 \\ F_0
  \end{pmatrix}
  =
  \begin{pmatrix}
    1 &amp; 1 \\
    1 &amp; 0
  \end{pmatrix}^{n - 1}
  \cdot
  \begin{pmatrix}
    1 \\ 0
  \end{pmatrix}\end{split}\]</div>
<p>Torej je <span class="math notranslate nohighlight">\(F_n\)</span> enak prvi komponenti matrike <span class="math notranslate nohighlight">\(\begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0\end{pmatrix}^{n - 1}\)</span>, ki pa jo lahko izračunamo s pomočjo hitrega potenciranja. Če bi matriko diagonalizirali, pa iz te potence dobimo znano Binetovo formulo.</p>
</div>
<div class="section" id="urejanje-z-zlivanjem">
<h2>Urejanje z zlivanjem<a class="headerlink" href="#urejanje-z-zlivanjem" title="Permalink to this headline">¶</a></h2>
<p>Strategija deli in vladaj je zelo koristna pri urejanju seznamov. Prvi algoritem, ki ga bomo spoznali, je <em>urejanje z zlivanjem</em> ali <em>mergesort</em>. Ta deluje tako, da seznam razdelimo na dva manjša podseznama (vseeno kakšna, le da vsak vsebuje približno polovico elementov prvotnega seznama), nato pa vsakega rekurzivno uredimo. Ko sta obe polovici urejeni, ju lahko <em>zlijemo</em> tako, da z njunih začetkov postopoma jemljemo najmanjše še ne vzete elemente:</p>
<p><img alt="" src="_images/urejanje-z-zlivanjem.png" /></p>
<p>V OCamlu lahko delitev na pol najenostavneje izvedemo tako, da damo v eno polovico elemente na lihih, v drugo pa elemente na sodih mestih:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">razdeli_na_pol</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span><span class="o">,</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">xs2</span> <span class="o">=</span> <span class="n">razdeli_na_pol</span> <span class="n">xs</span> <span class="k">in</span>
      <span class="n">x</span> <span class="o">::</span> <span class="n">xs2</span><span class="o">,</span> <span class="n">xs1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val razdeli_na_pol : &#39;a list -&gt; &#39;a list * &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">razdeli_na_pol</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list * int list = ([1; 3; 5; 7], [2; 4; 6; 8])
</pre></div>
</div>
</div>
</div>
<p>Zlivanje naredimo tako, da primerjamo glavi dveh seznamov, izberemo manjšo ter nadaljujemo rekurzivno. Ko je eden izmed seznamov prazen, vzamemo preostale elemente drugega seznama:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">zlij</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">xs</span><span class="o">,</span> <span class="n">ys</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">ys</span>
  <span class="o">|</span> <span class="o">_,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">xs</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs&#39;</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys&#39;</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="k">then</span>
        <span class="n">x</span> <span class="o">::</span> <span class="n">zlij</span> <span class="n">xs&#39;</span> <span class="n">ys</span>
      <span class="k">else</span>
        <span class="n">y</span> <span class="o">::</span> <span class="n">zlij</span> <span class="n">xs</span> <span class="n">ys&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val zlij : &#39;a list -&gt; &#39;a list -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">zlij</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">10</span><span class="o">;</span> <span class="mi">11</span><span class="o">;</span> <span class="mi">100</span><span class="o">;</span> <span class="mi">101</span><span class="o">;</span> <span class="mi">110</span><span class="o">;</span> <span class="mi">111</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">20</span><span class="o">;</span> <span class="mi">22</span><span class="o">;</span> <span class="mi">200</span><span class="o">;</span> <span class="mi">202</span><span class="o">;</span> <span class="mi">220</span><span class="o">;</span> <span class="mi">222</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [1; 2; 10; 11; 20; 22; 100; 101; 110; 111; 200; 202; 220; 222]
</pre></div>
</div>
</div>
</div>
<p>Seznam potem uredimo tako, kot smo omenili na začetku: razdelimo ga na pol, obe polovici rekurzivno uredimo in ju zlijemo. Pri tem ne smemo pozabiti na robni primer, ko je seznam tako majhen, da ga ne moremo več razdeliti na dve polovici:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">uredi_z_zlivanjem</span> <span class="n">sez</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">sez</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="o">-&gt;</span> <span class="n">sez</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">sez1</span><span class="o">,</span> <span class="n">sez2</span> <span class="o">=</span> <span class="n">razdeli_na_pol</span> <span class="n">sez</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">sez1&#39;</span> <span class="o">=</span> <span class="n">uredi_z_zlivanjem</span> <span class="n">sez1</span>
    <span class="ow">and</span> <span class="n">sez2&#39;</span> <span class="o">=</span> <span class="n">uredi_z_zlivanjem</span> <span class="n">sez2</span> <span class="k">in</span>
    <span class="n">zlij</span> <span class="n">sez1&#39;</span> <span class="n">sez2&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val uredi_z_zlivanjem : &#39;a list -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">uredi_z_zlivanjem</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [1; 2; 3; 3; 4; 5; 7; 9]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="casovna-zahtevnost-urejanja-z-zlivanjem">
<h2><strong>Časovna zahtevnost</strong> urejanja z zlivanjem<a class="headerlink" href="#casovna-zahtevnost-urejanja-z-zlivanjem" title="Permalink to this headline">¶</a></h2>
<p>Izračunajmo časovno zahtevnost urejanja z zlivanjem. Da uredimo seznam dolžine <span class="math notranslate nohighlight">\(n\)</span>, ga moramo najprej razdeliti na pol, kar lahko naredimo v času <span class="math notranslate nohighlight">\(O(n)\)</span>. Če želimo biti bolj učinkoviti, lahko delamo zgolj s premikanjem indeksov in ga tako razdelimo v času <span class="math notranslate nohighlight">\(O(1)\)</span>, vendar to splošne časovne zahtevnosti ne bo spremenilo, saj moramo seznama tudi zliti, kar zahteva <span class="math notranslate nohighlight">\(O(n)\)</span> časa, saj moramo narediti nov seznam dolžine <span class="math notranslate nohighlight">\(n\)</span>. Ostane nam še čas, ki ga porabimo za rekurzivno ureditev. Ker urejamo dva polovico manjša seznama, lahko vse skupaj zapišemo z rekurzivno zvezo</p>
<div class="math notranslate nohighlight">
\[T(n) = O(n) + 2 \cdot T(n / 2)\]</div>
<p>kjer s <span class="math notranslate nohighlight">\(T(n)\)</span> označimo čas, ki ga potrebujemo, da uredimo seznam dolžine <span class="math notranslate nohighlight">\(n\)</span>. Rešitev te enačbe je <span class="math notranslate nohighlight">\(T(n) = O(n \log n)\)</span>, kar je precej hitreje od naivnih algoritmov za urejanje, ki delujejo v času <span class="math notranslate nohighlight">\(O(n^2)\)</span>. Reševanje takih enačb presega obseg tega predmeta, intuicija za njim pa ni preveč zapletena. Enačbo postopoma razpisujemo:</p>
<p>\begin{align}
T(n)
&amp;= O(n) + 2 T(n / 2) \
&amp;= O(n) + 2 (O(n / 2) + 2 T(n / 4)) \
&amp;= O(n) + 2 O(n / 2) + 4 T(n / 4) \
&amp;= O(n) + 2 O(n / 2) + 4 O(n / 4) + 8 T(n / 8)
\end{align}</p>
<p>Vidimo, da v vsakem koraku dobimo dodaten člen z zahtevnostjo <span class="math notranslate nohighlight">\(O(n)\)</span>, kar po <span class="math notranslate nohighlight">\(k\)</span> korakih znaša</p>
<div class="math notranslate nohighlight">
\[T(n) = k O(n) + 2^k T(n / 2^k)\]</div>
<p>Ker lahko <span class="math notranslate nohighlight">\(n\)</span> razpolovimo <span class="math notranslate nohighlight">\(\lceil \log_2 n \rceil\)</span>-krat, na koncu dobimo</p>
<div class="math notranslate nohighlight">
\[T(n) = \lceil \log_2 n \rceil O(n) + 2^{\lceil \log_2 n \rceil} O(1) = O(n \log n)\]</div>
</div>
<div class="section" id="hitro-urejanje">
<h2>Hitro urejanje<a class="headerlink" href="#hitro-urejanje" title="Permalink to this headline">¶</a></h2>
<p>Drugi znani algoritem za urejanje pa je <em>hitro urejanje</em> ali <em>quicksort</em>. Tudi ta deluje tako, da seznam razdeli na dva manjša podseznama, vsakega rekurzivno uredi, na koncu pa obe urejeni polovici združi. Razlika je v tem, da več dela opravi pri deljenju seznama na dva dela. Pri tem elemente uredi tako, da so v eni polovici manjši, v drugi polovici pa večji elementi. Posledica tega je, da je združevanje enostavno, saj obe polovici samo še staknemo. Elemente razdelimo po velikosti glede na izbrani element, ki mu pravimo <em>pivot</em> in ga običajno vzamemo z začetka seznama. Na primer, v spodnji sliki za pivot vzamemo število <span class="math notranslate nohighlight">\(3\)</span>. Postopku deljenja zato pravimo <em>pivotiranje</em>.</p>
<p><img alt="" src="_images/hitro-urejanje.png" /></p>
<p>V OCamlu seznam enostavno pivotiramo s pomočjo funkcije <code class="docutils literal notranslate"><span class="pre">List.partition</span></code>, ki seznam razdeli na elemente, ki zadoščajo predikatu, in tiste, ki mu ne.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">pivotiraj</span> <span class="n">p</span> <span class="n">xs</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">)</span> <span class="n">xs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val pivotiraj : &#39;a -&gt; &#39;a list -&gt; &#39;a list * &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">pivotiraj</span> <span class="mi">3</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list * int list = ([2; 1; 3], [5; 9; 7; 4])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">hitro_uredi</span> <span class="n">sez</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">sez</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="o">-&gt;</span> <span class="n">sez</span>
  <span class="o">|</span> <span class="n">p</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">sez1</span><span class="o">,</span> <span class="n">sez2</span> <span class="o">=</span> <span class="n">pivotiraj</span> <span class="n">p</span> <span class="n">xs</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">sez1&#39;</span> <span class="o">=</span> <span class="n">hitro_uredi</span> <span class="n">sez1</span>
    <span class="ow">and</span> <span class="n">sez2&#39;</span> <span class="o">=</span> <span class="n">hitro_uredi</span> <span class="n">sez2</span> <span class="k">in</span>
    <span class="n">sez1&#39;</span> <span class="o">@</span> <span class="n">p</span> <span class="o">::</span> <span class="n">sez2&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val hitro_uredi : &#39;a list -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">hitro_uredi</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [1; 2; 3; 3; 4; 5; 7; 9]
</pre></div>
</div>
</div>
</div>
<p>Za pivotiranje in stikanje skupaj porabimo linearno mnogo časa. Tako ob predpostavki, da pivot pade približno na sredino urejenega seznama, pri hitrem urejanju seznam velikosti <span class="math notranslate nohighlight">\(n\)</span> razdelimo na dva podseznama velikosti <span class="math notranslate nohighlight">\(n / 2\)</span>, zato za časovno zahtevnost zopet dobimo enačbo</p>
<div class="math notranslate nohighlight">
\[T(n) = O(n) + 2 T(n / 2) = O(n \log n)\]</div>
<p>Vendar zgornji predpostavki ni vedno zadoščeno. Na primer, če je seznam že urejen (ali skoraj urejen), je prvi seznam skoraj prazen, drugi pa le malenkost manjši, zato dobimo enačbo <span class="math notranslate nohighlight">\(T(n) = O(n) + T(n - 1)\)</span>, kar vodi v zahtevnost <span class="math notranslate nohighlight">\(O(n^2)\)</span>. Temu se lahko izognemo tako, da za pivot izberemo naključni element, da seznam pred urejanjem premešamo (npr. s Fisher-Yatesovim algoritmom), ali kaj podobnega. V praksi se tako izkaže, da je hitro urejanje kljub slabši asimptotski zahtevnosti hitrejše od urejanja z zlivanjem.</p>
<p>Poleg tega ima hitro urejanje dodatno prednost, da z njim lahko seznam predstavljen s tabelo uredimo na mestu brez porabe dodatnega prostora.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">zamenjaj</span> <span class="n">tabela</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tabela</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">tabela</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tabela</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
  <span class="n">tabela</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">t</span>

<span class="k">let</span> <span class="n">pivotiraj_na_mestu</span> <span class="n">tabela</span> <span class="n">i0</span> <span class="n">j0</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">tabela</span><span class="o">.(</span><span class="n">i0</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="ow">and</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">j0</span> <span class="k">in</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span> <span class="k">do</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">tabela</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="k">do</span>
      <span class="n">incr</span> <span class="n">i</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">tabela</span><span class="o">.(!</span><span class="n">j</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">pivot</span> <span class="k">do</span>
      <span class="n">decr</span> <span class="n">j</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="n">zamenjaj</span> <span class="n">tabela</span> <span class="o">!</span><span class="n">i</span> <span class="o">!</span><span class="n">j</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="k">if</span> <span class="n">tabela</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="k">then</span> <span class="o">!</span><span class="n">i</span> <span class="k">else</span> <span class="o">!</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="n">zamenjaj</span> <span class="n">tabela</span> <span class="n">i0</span> <span class="n">p</span><span class="o">;</span>
  <span class="n">p</span>

<span class="k">let</span> <span class="n">hitro_uredi_na_mestu</span> <span class="n">tabela</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">uredi_med_indeksoma</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pivotiraj_na_mestu</span> <span class="n">tabela</span> <span class="n">i</span> <span class="n">j</span> <span class="k">in</span>
      <span class="n">uredi_med_indeksoma</span> <span class="n">i</span> <span class="o">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
      <span class="n">uredi_med_indeksoma</span> <span class="o">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">j</span>
  <span class="k">in</span>
  <span class="n">uredi_med_indeksoma</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">tabela</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val zamenjaj : &#39;a array -&gt; int -&gt; int -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val pivotiraj_na_mestu : &#39;a array -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val hitro_uredi_na_mestu : &#39;a array -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Oba algoritma za urejanje, ki smo ju spoznali, imata optimalno časovno zahtevnost za urejanje s primerjavo. To pomeni, da ima vsak algoritem, ki bi pri urejanju uporabljal primerjavo elementov, časovno zahtevnost vsaj <span class="math notranslate nohighlight">\(O(n \log n)\)</span>. Razlog se skriva v tem, da vsak tak algoritem porodi odločitveno drevo, v katerem so vozlišča primerjave elementov, listi pa permutacije prvotnega seznama.</p>
<p>Na primer, eno tako drevo, ki ga porodi urejanje z mehurčki na seznamu <span class="math notranslate nohighlight">\([x, y, z]\)</span>, je:</p>
<p><img alt="" src="_images/odlocitveno-drevo.png" /></p>
<p>Če bi izbrali drug algoritem, bi dobili drugačno drevo. Bolj plitko je drevo, hitrejši je algoritem. Toda ne glede na to, kako plitko je drevo, mora imeti vsaj <span class="math notranslate nohighlight">\(n!\)</span> listov, ker obstaja vsaj toliko različnih permutacij, ki jih mora vrniti. Zato mora biti odločitveno drevo globine vsaj <span class="math notranslate nohighlight">\(\log n!\)</span>. Hitro lahko ocenimo, da je <span class="math notranslate nohighlight">\(n! &gt; (n / 2)^{n / 2}\)</span>, zato je <span class="math notranslate nohighlight">\(\log(n!) &gt; (n / 2) \log(n / 2) = O(n \log n)\)</span>.</p>
<p>Če pri urejanju uporabljamo še dodatne predpostavke, na primer, da so vsi elementi števila v nekem razponu, pridemo do <a class="reference external" href="https://visualgo.net/en/sorting">še hitrejših algoritmov</a>.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "ocaml-jupyter"
        },
        kernelOptions: {
            kernelName: "ocaml-jupyter",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'ocaml-jupyter'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="10-spremenljive-podatkovne-strukture.html" title="previous page">Spremenljive podatkovne strukture</a>
    <a class='right-next' id="next-link" href="12-dinamicno-programiranje.html" title="next page">Dinamično programiranje</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Matija Pretnar<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>